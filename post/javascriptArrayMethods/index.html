<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>数组的方法 | 遗落空间</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://gaobin16.github.io/favicon.ico?v=1585379657890">
<link rel="stylesheet" href="https://gaobin16.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="一、js原生操作数组
数组创建
JavaScript中创建数组有两种方式，第一种是使用 Array 构造函数：
var arr1 = new Array(); //创建一个空数组
var arr2 = new Array(20); // 创..." />
    <meta name="keywords" content="javascript" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://gaobin16.github.io">
        <img src="https://gaobin16.github.io/images/avatar.png?v=1585379657890" class="site-logo">
        <h1 class="site-title">遗落空间</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://gaobin16.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">数组的方法</h2>
            <div class="post-date">2020-03-28</div>
            
            <div class="post-content" v-pre>
              <h2 id="一-js原生操作数组">一、js原生操作数组</h2>
<h3 id="数组创建">数组创建</h3>
<h6 id="javascript中创建数组有两种方式第一种是使用-array-构造函数">JavaScript中创建数组有两种方式，第一种是使用 Array 构造函数：</h6>
<pre><code>var arr1 = new Array(); //创建一个空数组
var arr2 = new Array(20); // 创建一个包含20项的数组
var arr3 = new Array(&quot;lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;); // 创建一个包含3个字符串的数组
</code></pre>
<h6 id="创建数组的第二种基本方式是使用数组字面量表示法">创建数组的第二种基本方式是使用数组字面量表示法：</h6>
<pre><code>var arr4 = []; //创建一个空数组
var arr5 = [20]; // 创建一个包含1项的数组
var arr6 = [&quot;lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;]; // 创建一个包含3个字符串的数组
</code></pre>
<h6 id="在读取和设置数组的值时要使用方括号并提供相应值的基于-0-的数字索引">在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引：</h6>
<pre><code>var arr6 = [&quot;lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;]; // 创建一个包含3个字符串的

alert(arr6[0]); //lily
arr6[1] = &quot;mary&quot;; //修改第二项为mary
arr6[3] = &quot;sean&quot;; //增加第四项为sean
</code></pre>
<h6 id="javascript中数组的length属性是可以修改的看下面的示例">JavaScript中数组的length属性是可以修改的，看下面的示例：</h6>
<pre><code>var arr = [&quot;lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;]; // 创建一个包含3个字符串的数组
arr[arr.length] = &quot;sean&quot;; //在下标为3处（也就是数组尾部）添加一项&quot;sean&quot;
arr.length = arr.length-1; //将数组的最后一项删除
</code></pre>
<p>如果需要判断一个对象是不是数组对象，在ECMAScript 5之前，我们可以通过 instanceof Array去判断，但是instanceof 操作符的问题在于，它假定只有一个全局执行环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</p>
<p>ECMAScript 5 新增了 Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。</p>
<h2 id="数组方法">数组方法</h2>
<p>下面开始介绍数组的方法，数组的方法有数组原型方法，也有从object对象继承来的方法，这里我们只介绍数组的原型方法，数组原型方法主要有以下这些：</p>
<h6 id="join">join()</h6>
<h6 id="push和pop">push()和pop()</h6>
<h6 id="shift-和-unshift">shift() 和 unshift()</h6>
<h6 id="sort">sort()</h6>
<h6 id="reverse">reverse()</h6>
<h6 id="concat">concat()</h6>
<h6 id="slice">slice()</h6>
<h6 id="splice">splice()</h6>
<h6 id="indexof和-lastindexof-es5新增">indexOf()和 lastIndexOf() （ES5新增）</h6>
<h6 id="foreach-es5新增">forEach() （ES5新增）</h6>
<h6 id="map-es5新增">map() （ES5新增）</h6>
<h6 id="filter-es5新增">filter() （ES5新增）</h6>
<h6 id="every-es5新增">every() （ES5新增）</h6>
<h6 id="some-es5新增">some() （ES5新增）</h6>
<h6 id="reduce和-reduceright-es5新增">reduce()和 reduceRight() （ES5新增）</h6>
<h5 id="针对es5新增的方法浏览器支持情况">针对ES5新增的方法浏览器支持情况：</h5>
<p>Opera 11+<br>
Firefox 3.6+<br>
Safari 5+<br>
Chrome 8+<br>
Internet Explorer 9+</p>
<h6 id="对于支持的浏览器版本可以通过array原型扩展来实现-下面详细介绍一下各个方法的基本功能">对于支持的浏览器版本，可以通过Array原型扩展来实现。下面详细介绍一下各个方法的基本功能。</h6>
<h5 id="1-join">1、join()</h5>
<h6 id="joinseparator-将数组的元素组起一个字符串以separator为分隔符省略的话则用默认用逗号为分隔符该方法只接收一个参数即分隔符">join(separator): 将数组的元素组起一个字符串，以separator为分隔符，省略的话则用默认用逗号为分隔符，该方法只接收一个参数：即分隔符。</h6>
<pre><code>var arr = [1,2,3];
console.log(arr.join()); // 1,2,3
console.log(arr.join(&quot;-&quot;)); // 1-2-3
console.log(arr); // [1, 2, 3]（原数组不变）
</code></pre>
<h6 id="通过join方法可以实现重复字符串只需传入字符串以及重复的次数就能返回重复后的字符串函数如下">通过join()方法可以实现重复字符串，只需传入字符串以及重复的次数，就能返回重复后的字符串，函数如下：</h6>
<pre><code>function repeatString(str, n) {
    return new Array(n + 1).join(str);
}
console.log(repeatString(&quot;abc&quot;, 3)); // abcabcabc
console.log(repeatString(&quot;Hi&quot;, 5)); // HiHiHiHiHi
</code></pre>
<h5 id="2-push和pop">2、push()和pop()</h5>
<h6 id="push-可以接收任意数量的参数把它们逐个添加到数组末尾并返回修改后数组的长度">push(): 可以接收任意数量的参数，把它们逐个添加到数组末尾，并返回修改后数组的长度。</h6>
<h6 id="pop数组末尾移除最后一项减少数组的-length-值然后返回移除的项">pop()：数组末尾移除最后一项，减少数组的 length 值，然后返回移除的项。</h6>
<pre><code>var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];
var count = arr.push(&quot;Jack&quot;,&quot;Sean&quot;);
console.log(count); // 5
console.log(arr); // [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;, &quot;Sean&quot;]
var item = arr.pop();
console.log(item); // Sean
console.log(arr); // [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;]
</code></pre>
<h5 id="3-shift-和-unshift">3、shift() 和 unshift()</h5>
<h6 id="shift删除原数组第一项并返回删除元素的值如果数组为空则返回undefined">shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。</h6>
<h6 id="unshift将参数添加到原数组开头并返回数组的长度">unshift:将参数添加到原数组开头，并返回数组的长度 。</h6>
<p>这组方法和上面的push()和pop()方法正好对应，一个是操作数组的开头，一个是操作数组的结尾。</p>
<pre><code>var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];
var count = arr.unshift(&quot;Jack&quot;,&quot;Sean&quot;);
console.log(count); // 5
console.log(arr); //[&quot;Jack&quot;, &quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]
var item = arr.shift();
console.log(item); // Jack
console.log(arr); // [&quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]
</code></pre>
<h5 id="4-sort">4、sort()</h5>
<h6 id="sort按升序排列数组项即最小的值位于最前面最大的值排在最后面">sort()：按升序排列数组项——即最小的值位于最前面，最大的值排在最后面。</h6>
<h6 id="在排序时sort方法会调用每个数组项的-tostring转型方法然后比较得到的字符串以确定如何排序-即使数组中的每一项都是数值-sort方法比较的也是字符串因此会出现以下的这种情况">在排序时，sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值， sort()方法比较的也是字符串，因此会出现以下的这种情况：</h6>
<pre><code>var arr1 = [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;];
console.log(arr1.sort()); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
arr2 = [13, 24, 51, 3];
console.log(arr2.sort()); // [13, 24, 3, 51]
console.log(arr2); // [13, 24, 3, 51](元数组被改变)
</code></pre>
<p>为了解决上述问题，sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个之后则返回一个正数。以下就是一个简单的比较函数：</p>
<pre><code>function compare(value1, value2) {
    if (value1 &lt; value2) {
        return -1;
    } else if (value1 &gt; value2) {
        return 1;
    } else {
        return 0;
    }
}
arr2 = [13, 24, 51, 3];
console.log(arr2.sort(compare)); // [3, 13, 24, 51]
</code></pre>
<p>如果需要通过比较函数产生降序排序的结果，只要交换比较函数返回的值即可：</p>
<pre><code>function compare(value1, value2) {
    if (value1 &lt; value2) {
        return 1;
    } else if (value1 &gt; value2) {
        return -1;
    } else {
        return 0;
    }
}
arr2 = [13, 24, 51, 3];
console.log(arr2.sort(compare)); // [51, 24, 13, 3]
</code></pre>
<h5 id="5-reverse">5、reverse()</h5>
<h6 id="reverse反转数组项的顺序">reverse()：反转数组项的顺序。</h6>
<pre><code>var arr = [13, 24, 51, 3];
console.log(arr.reverse()); //[3, 51, 24, 13]
console.log(arr); //[3, 51, 24, 13](原数组改变)
</code></pre>
<h5 id="6-concat">6、concat()</h5>
<h6 id="concat-将参数添加到原数组中-这个方法会先创建当前数组一个副本然后将接收到的参数添加到这个副本的末尾最后返回新构建的数组-在没有给-concat方法传递参数的情况下它只是复制当前数组并返回副本">concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</h6>
<pre><code>var arr = [1,3,5,7];
var arrCopy = arr.concat(9,[11,13]);
console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]
console.log(arr); // [1, 3, 5, 7](原数组未被修改)
</code></pre>
<p>从上面测试结果可以发现：传入的不是数组，则直接把参数添加到数组后面，如果传入的是数组，则将数组中的各个项添加到数组中。但是如果传入的是一个二维数组呢？</p>
<pre><code>var arrCopy2 = arr.concat([9,[11,13]]);
console.log(arrCopy2); //[1, 3, 5, 7, 9, Array[2]]
console.log(arrCopy2[5]); //[11, 13]
arr = [2];
console.log(arr); //[2]
console.log(arrCopy2); // [1, 3, 5, 7, 9, Array[2]]
</code></pre>
<p>上述代码中，arrCopy2数组的第五项是一个包含两项的数组，也就是说concat方法只能将传入数组中的每一项添加到数组中，如果传入数组中有些项是数组，那么也会把这一数组项当作一项添加到arrCopy2中。</p>
<p>即使后面改变数组也不会影响新构建的数组</p>
<h5 id="7-slice">7、slice()</h5>
<h6 id="slice返回从原数组中指定开始下标到结束下标之间的项组成的新数组-slice方法可以接受一或两个参数即要返回项的起始和结束位置-在只有一个参数的情况下-slice方法返回从该参数指定位置开始到当前数组末尾的所有项-如果有两个参数该方法返回起始和结束位置之间的项但不包括结束位置的项">slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。</h6>
<pre><code>var arr = [1,3,5,7,9,11];
var arrCopy = arr.slice(1);
var arrCopy2 = arr.slice(1,4);
var arrCopy3 = arr.slice(1,-2);
var arrCopy4 = arr.slice(-4,-1);
console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)
console.log(arrCopy); //[3, 5, 7, 9, 11]
console.log(arrCopy2); //[3, 5, 7]
console.log(arrCopy3); //[3, 5, 7]
console.log(arrCopy4); //[5, 7, 9]
</code></pre>
<p>arrCopy只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。<br>
arrCopy2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。</p>
<p>arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。</p>
<p>arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。</p>
<h5 id="8-splice">8、splice()</h5>
<h6 id="splice很强大的数组方法它有很多种用法可以实现删除-插入和替换">splice()：很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。</h6>
<h6 id="删除可以删除任意数量的项只需指定-2-个参数要删除的第一项的位置和要删除的项数-例如-splice02会删除数组中的前两项">删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。</h6>
<h6 id="插入可以向指定位置插入任意数量的项只需提供-3-个参数起始位置-0要删除的项数和要插入的项-例如splice2046会从当前数组的位置-2-开始插入4和6">插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。</h6>
<h6 id="替换可以向指定位置插入任意数量的项且同时删除任意数量的项只需指定-3-个参数起始位置-要删除的项数和要插入的任意数量的项-插入的项数不必与删除的项数相等-例如splice-2146会删除当前数组位置-2-的项然后再从位置-2-开始插入4和6">替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。</h6>
<h6 id="splice方法始终都会返回一个数组该数组中包含从原始数组中删除的项如果没有删除任何项则返回一个空数组">splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。</h6>
<pre><code>var arr = [1,3,5,7,9,11];
var arrRemoved = arr.splice(0,2);
console.log(arr); //[5, 7, 9, 11]
console.log(arrRemoved); //[1, 3]
var arrRemoved2 = arr.splice(2,0,4,6);
console.log(arr); // [5, 7, 4, 6, 9, 11]
console.log(arrRemoved2); // []
var arrRemoved3 = arr.splice(1,1,2,4);
console.log(arr); // [5, 2, 4, 4, 6, 9, 11]
console.log(arrRemoved3); //[7]
</code></pre>
<h4 id="9-indexof和-lastindexof">9、indexOf()和 lastIndexOf()</h4>
<h6 id="indexof接收两个参数要查找的项和可选的表示查找起点位置的索引-其中-从数组的开头位置-0开始向后查找">indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。</h6>
<h6 id="lastindexof接收两个参数要查找的项和可选的表示查找起点位置的索引-其中-从数组的末尾开始向前查找">lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。</h6>
<h6 id="这两个方法都返回要查找的项在数组中的位置或者在没找到的情况下返回-1-在比较第一个参数与数组中的每一项时会使用全等操作符">这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。</h6>
<pre><code>var arr = [1,3,5,7,7,5,3,1];
console.log(arr.indexOf(5)); //2
console.log(arr.lastIndexOf(5)); //5
console.log(arr.indexOf(5,2)); //2
console.log(arr.lastIndexOf(5,4)); //2
console.log(arr.indexOf(&quot;5&quot;)); //-1
</code></pre>
<h5 id="10-foreach">10、forEach()</h5>
<h6 id="foreach对数组进行遍历循环对数组中的每一项运行给定函数-这个方法没有返回值-参数都是function类型默认有传参参数分别为遍历的数组内容第对应的数组索引数组本身">forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。</h6>
<pre><code>var arr = [1, 2, 3, 4, 5];
arr.forEach(function(x, index, a){
console.log(x + '|' + index + '|' + (a === arr));
});
// 输出为：
// 1|0|true
// 2|1|true
// 3|2|true
// 4|3|true
// 5|4|true
</code></pre>
<h5 id="11-map">11、map()</h5>
<h6 id="map指映射对数组中的每一项运行给定函数返回每次函数调用的结果组成的数组不改变原数组">map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组（不改变原数组）。</h6>
<p>下面代码利用map方法实现数组中每个数求平方。</p>
<pre><code>var arr = [1, 2, 3, 4, 5];
var arr2 = arr.map(function(item){
    return item*item;
});
console.log(arr2); //[1, 4, 9, 16, 25]
</code></pre>
<h5 id="12-filter">12、filter()</h5>
<h6 id="filter过滤功能数组中的每一项运行给定函数返回满足过滤条件组成的数组不改变原数组">filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组（不改变原数组）。</h6>
<pre><code>var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var arr2 = arr.filter(function(x, index) { // x数组内容，index索引
    return index % 3 === 0 || x &gt;= 8;
}); 
console.log(arr2); //[1, 4, 7, 8, 9, 10]
</code></pre>
<h5 id="13-every">13、every()</h5>
<h6 id="every判断数组中每一项都是否满足条件只有所有项都满足条件才会返回true">every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。</h6>
<pre><code>var arr = [1, 2, 3, 4, 5];
var arr2 = arr.every(function(x) {
    return x &lt; 10;
}); 
console.log(arr2); //true
var arr3 = arr.every(function(x) {
    return x &lt; 3;
}); 
console.log(arr3); // false
</code></pre>
<h5 id="14-some">14、some()</h5>
<h6 id="some判断数组中是否存在满足条件的项只要有一项满足条件就会返回true">some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。</h6>
<pre><code>var arr = [1, 2, 3, 4, 5];
var arr2 = arr.some(function(x) {
    return x &lt; 3;
}); 
console.log(arr2); //true
var arr3 = arr.some(function(x) {
    return x &lt; 1;
}); 
console.log(arr3); // false
</code></pre>
<h5 id="15-reduce和-reduceright">15、reduce()和 reduceRight()</h5>
<h6 id="这两个方法都会实现迭代数组的所有项然后构建一个最终返回的值-reduce方法从数组的第一项开始逐个遍历到最后-而-reduceright则从数组的最后一项开始向前遍历到第一项">这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后。而 reduceRight()则从数组的最后一项开始，向前遍历到第一项。</h6>
<h6 id="这两个方法都接收两个参数一个在每一项上调用的函数和可选的作为归并基础的初始值">这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。</h6>
<h6 id="传给-reduce和-reduceright的函数接收-4-个参数前一个值-当前值-项的索引和数组对象-这个函数返回的任何值都会作为第一个参数自动传给下一项-第一次迭代发生在数组的第二项上因此第一个参数是数组的第一项第二个参数就是数组的第二项">传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</h6>
<h6 id="下面代码用reduce实现数组求和数组一开始加了一个初始值10">下面代码用reduce()实现数组求和，数组一开始加了一个初始值10。</h6>
<pre><code>var values = [1,2,3,4,5];
var sum = values.reduceRight(function(prev, cur, index, array){
    return prev + cur;
},10);
console.log(sum); //25
</code></pre>
<h2 id="二-jquery常用js方法">二、Jquery常用js方法</h2>
<h5 id="1遍历">1.遍历</h5>
<h6 id="可以对所有的元素进行操作-如果想要满足条件退出用return-false-绝大部分jquery方法都可以这么退出">可以对所有的元素进行操作。如果想要满足条件退出，用return false( 绝大部分jquery方法都可以这么退出)。</h6>
<pre><code>$.each(arr, callback(key, val));      //可以链式调用，返回arr，为本身
var a = [1, 2, 3, 4];
$.each(a, function(key, val) {     //以jQuery对象的方法调用，兼容性好;也可以用$(a)将a转化为jquery对象，然后以$(a).each(function(){})的形式调用,下面的方法同
    console.log(a[key] + '下标为' + key + '值为' + val);
});
</code></pre>
<h6 id="对应源码jquery1110下面同">//对应源码(jquery1.11.0下面同)</h6>
<pre><code>// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.
each: function( obj, callback, args ) {
        var value,
            i = 0,
            length = obj.length,
            isArray = isArraylike( obj );

    if ( args ) {
        if ( isArray ) {
            for ( ; i &lt; length; i++ ) {
                value = callback.apply( obj[ i ], args );   //第三个参数用于扩展obj元素的方法,一般不用

                if ( value === false ) {
                    break;
                }
            }
        } else {
            for ( i in obj ) {
                value = callback.apply( obj[ i ], args );

                if ( value === false ) {
                    break;
                }
            }
        }

    // A special, fast, case for the most common use of each
    } else {
        if ( isArray ) {
            for ( ; i &lt; length; i++ ) {
                value = callback.call( obj[ i ], i, obj[ i ] );

                if ( value === false ) {
                    break;
                }
            }
        } else {
            for ( i in obj ) {
                value = callback.call( obj[ i ], i, obj[ i ] );

                if ( value === false ) {
                    break;
                }
            }
        }
    }

    return obj;
}
</code></pre>
<h5 id="2-筛选">2. 筛选</h5>
<pre><code>$.grep(arr, callback, invert)   
</code></pre>
<h6 id="invert为false表示对callback的筛选取反-默认为true">invert为false表示对callback的筛选取反。 默认为true。</h6>
<pre><code>var a = [1, 2, 3, 4];
$.grep(a, function(val, key) {  //不能链式调用，返回[],所以可以加上return实现链式,返回满足条件的副本
　　if (a[key] &gt; 2) {
　　　　console.log(key);
　　}
　　return val;
});
</code></pre>
<h6 id="常用做获取两个数组中相同或不相同的部分">常用做获取两个数组中相同(或不相同)的部分</h6>
<pre><code>var a= [1, 2, 3, 4],
    b=[1,3,5,7];
$.grep(a,function(val,key){
    if(b.indexOf(val)&gt;=0){
        return val;
    }
},false);
</code></pre>
<h6 id="jquery源码">jquery源码</h6>
<pre><code>grep: function( elems, callback, invert ) {
        var callbackInverse,
            matches = [],
            i = 0,
            length = elems.length,
            callbackExpect = !invert;

    // Go through the array, only saving the items
    // that pass the validator function
    for ( ; i &lt; length; i++ ) {
        callbackInverse = !callback( elems[ i ], i );   //如果callback没有设置return，那么返回undefined(!undefined还是undefined)
        if ( callbackInverse !== callbackExpect ) {
            matches.push( elems[ i ] );          //只添加满足条件的,内部实现为push方法
        }
    }

    return matches;
}
</code></pre>
<h5 id="3转换">3.转换</h5>
<pre><code>$.map(arr,callback(key,val))

var a = [1, 2, 3, 4];
$.map(a, function(val, key) { //不能链式调用，返回[],同grep加上return即可放回副本
    if (a[key] &gt; 2) {
        a[key]=val+1;
    }
    return val;              //可以链式调用，返回处理后的数组(也可用于筛选)
});
</code></pre>
<h6 id="源码">源码</h6>
<pre><code>// arg is for internal usage only
    map: function( elems, callback, arg ) {
        var value,
            i = 0,
            length = elems.length,
            isArray = isArraylike( elems ),
            ret = [];

    // Go through the array, translating each of the items to their new values
    if ( isArray ) {
        for ( ; i &lt; length; i++ ) {
            value = callback( elems[ i ], i, arg );

            if ( value != null ) {
                ret.push( value );
            }
        }

    // Go through every key on the object,
    } else {
        for ( i in elems ) {
            value = callback( elems[ i ], i, arg );   //如果callback没有返回值，那么value就是undefined

            if ( value != null ) {
                ret.push( value );
            }
        }
    }

    // Flatten any nested arrays
    return concat.apply( [], ret );                   //如果callback没有返回值，那么value就是[]
}
</code></pre>
<h5 id="4合并">4.合并</h5>
<pre><code>$.merge(arr1,arr2)  arr1后面加上arr2后返回arr1
var a=[1,2,3],
    b=[4,5,6];
$.merge(a,b);             //可以有多个参数(居然不报错!)，但是第三个及以后的没用(test in FF and Chrome)
</code></pre>
<h6 id="源码-2">源码</h6>
<pre><code>   merge: function( first, second ) {
        var len = +second.length, 
            j = 0,
            i = first.length;

    while ( j &lt; len ) {
        first[ i++ ] = second[ j++ ];
    }

    // Support: IE&lt;9
    // Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
    if ( len !== len ) {
        while ( second[j] !== undefined ) {
            first[ i++ ] = second[ j++ ];
        }
    }

    first.length = i;

    return first;
}
</code></pre>
<h6 id="源码的第二行有个最开始我以为是显式声明非负值后来看到了arraylike于是测试了极端情况如下">源码的第二行有个+，最开始我以为是显式声明非负值，后来看到了arraylike，于是测试了极端情况如下:</h6>
<pre><code>var ax;
ax.length        //报错，type error
+ax.length       //报错，type error

var ab={};       //空对象作为类空数组对象
ab.length        //undefined
+ab.length       //NaN

var ab=[];
ab.length        //0
+ab.length       //0

var ab=null;
ab.length　　　　 //报错，type error
+ab.length       //报错，type error
</code></pre>
<h5 id="7元素转数组">7.元素转数组</h5>
<h6 id="makearray将一个类数组对象转换为真正的数组对象-所谓类数组对象就是一个常规的object对象但它和数组对象非常相似具备length属性并以0-1-2-3等数字作为属性名-不过它毕竟不是数组没有从数组的原型对象上继承下来的内置方法例如push-sort等">$.makeArray()将一个类数组对象转换为真正的数组对象。(所谓&quot;类数组对象&quot;就是一个常规的Object对象，但它和数组对象非常相似：具备length属性，并以0、1、2、3……等数字作为属性名。不过它毕竟不是数组，没有从数组的原型对象上继承下来的内置方法(例如：push()、 sort()等)。)</h6>
<pre><code> $.toArray()将所有DOM元素恢复成数组。(其实用选择器取的时候就是很自然的数组的形式)
</code></pre>
<h6 id="这两个实际用得太少了就不具体分析了知道有这玩意就行吧">这两个实际用得太少了就不具体分析了，知道有这玩意就行吧。</h6>
<pre><code> The Array.from() method creates a new Array instance from an array-like or iterable
 
console.log(Array.from('foo'));
// expected output: Array [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]

console.log(Array.from([1, 2, 3], x =&gt; x + x));
// expected output: Array [2, 4, 6]
</code></pre>
<h2 id="三补充">三.补充</h2>
<h5 id="1清空数组">1.清空数组</h5>
<h6 id="方法1length设为0-js身为弱变量类型语言的体现之一array的length属性可写效率比较低">方法1:length设为0 (js身为弱变量类型语言的体现之一，array的length属性可写)(效率比较低)</h6>
<h6 id="方法2直接指向的引用-如闭包销毁指向null一样垃圾回收会自动回收空间效率比较高">方法2:直接指向[]的引用 (如闭包销毁指向null一样，垃圾回收会自动回收空间)(效率比较高)</h6>
<h5 id="2兼容性">2.兼容性</h5>
<h6 id="ie8下">IE8下</h6>
<pre><code>$.inArray 代替 indexOf
$.grep代替Array.prototype.filter
</code></pre>
<h5 id="3注意事项">3.注意事项</h5>
<h6 id="一般情况下用functionnameobjcallback的形式调用jquery方法的兼容性比较好比如我曾遇到ie8及以下不能识别domvaltrim的情况显示trim-is-not-a-function然而改为trimdomval就没问题">一般情况下用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>(</mo><mi>o</mi><mi>b</mi><mi>j</mi><mo separator="true">,</mo><mi>c</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>b</mi><mi>a</mi><mi>c</mi><mi>k</mi><mo>)</mo><mi mathvariant="normal">的</mi><mi mathvariant="normal">形</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">调</mi><mi mathvariant="normal">用</mi><mi>j</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>r</mi><mi>y</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">兼</mi><mi mathvariant="normal">容</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">较</mi><mi mathvariant="normal">好</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">如</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">曾</mi><mi mathvariant="normal">遇</mi><mi mathvariant="normal">到</mi><mi>I</mi><mi>E</mi><mn>8</mn><mi mathvariant="normal">及</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">下</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">识</mi><mi mathvariant="normal">别</mi></mrow><annotation encoding="application/x-tex">.functionName(obj,callback)的形式调用jquery方法的兼容性比较好，比如我曾遇到IE8及以下不能识别</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">b</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">形</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">调</span><span class="mord cjk_fallback">用</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">兼</span><span class="mord cjk_fallback">容</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">较</span><span class="mord cjk_fallback">好</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">如</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">曾</span><span class="mord cjk_fallback">遇</span><span class="mord cjk_fallback">到</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord">8</span><span class="mord cjk_fallback">及</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">下</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">识</span><span class="mord cjk_fallback">别</span></span></span></span>(dom).val().trim()的情况，显示trim is not a function，然而改为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>m</mi><mo>(</mo></mrow><annotation encoding="application/x-tex">.trim(</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">.</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mopen">(</span></span></span></span>(dom).val())就没问题。</h6>
<h6 id="前面那种情况实际是string调用trim方法如果加上call或者apply注入trim方法可以过但是必要嘛后面是jquery对象调用trim方法">前面那种情况实际是string调用trim方法(如果加上call或者apply注入trim方法可以过，但是必要嘛？)，后面是jquery对象调用trim方法。</h6>
<figure data-type="image" tabindex="1"><img src="https://images0.cnblogs.com/blog2015/756653/201507/271918293756223.jpg" alt="image" loading="lazy"></figure>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://gaobin16.github.io/tag/PJTg37op7_/" class="tag">
                    javascript
                  </a>
                
              </div>
            
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
